
from mpWrapper import MediaPlayer, MediaPlayerState
import pytube, os, threading, re, enum, time, datetime
from icecream import ic
import settings, client
from pytube.exceptions import AgeRestrictedError
import pytube.exceptions as pyex
from ssl import SSLError
import ffmpeg
import shutil

class PlaylistPlaybackManager(object):
    
    def __init__(self, url, output_folder, file_type) -> None:
        self.stop = False
        self.playlist = pytube.Playlist(url)
        try:
            client.hail(message=self.playlist.title)
        except KeyError as e:
            client.warn(message="Playlist information cannot be accessed")
            client.warn(message="Cannot create playback from Private Playlist or Youtube Mix.")
            raise e

        self.videos = [MediaPlayer]
        self.current_mp = 0
        self.preferred_file_type = file_type
        
        # Replace invalid characters with underscores in the playlist title
        sanitized_title = re.sub(r'[\\/:*?"<>|]', '_', self.playlist.title)
        self.path = output_folder + self.playlist.playlist_id + "\\" + sanitized_title + "\\"
        if not os.path.exists(self.path): os.makedirs(self.path)

        ic ("PlaylistPlaybackManager initiated successfully.")


    def play(self, callback) -> None:
        iterator = self.yield_iterate()
        current_media_player = next(iterator, None)

        client.currIndentLevel += 1

        while self.current_mp < len(self.videos) and self.stop is False:
            if (current_media_player is None):
                current_media_player = next(iterator, None) 

                continue

            ic(callback(current_media_player))
            
            # Prepare the status update, generated by the iterator to be overwritten.
            client.go_up_lines(1)
            client.clear_curr_line()

            state = ic(VideoPlaybackManager.play(current_media_player))

            if state == MediaPlayerState.ROLL_BACK:
                current_media_player = self.get_prev() 
            else: 
                current_media_player = next(iterator, None) 

        client.currIndentLevel -= 1


    def fill(self) -> [MediaPlayer]:
        for video in self.playlist.videos:
            ic(self.videos.append(VideoPlaybackManager.create_playback_from_video( video, self.path, self.preferred_file_type)))
        return self.videos 


    def yield_iterate(self):
        for video in self.playlist.videos_generator():
            client.info(ic("Generate Video: "))
            ic(self.videos.append(VideoPlaybackManager.create_playback_from_video( video, self.path, self.preferred_file_type)))
            yield self.get_next()

    def get_prev(self) -> MediaPlayer | None:
        if self.current_mp > 0:
            self.current_mp -= 1
            return self.get_current()
        return None
    
    def get_next(self) -> MediaPlayer | None:
        if self.current_mp < len(self.videos):
            self.current_mp += 1
            return self.get_current()
        return None

    def get_current(self) -> MediaPlayer | None:
        return self.videos[self.current_mp] if self.current_mp > 0 and self.current_mp < len(self.videos) else None
    

class VideoPlaybackManager:
    # returns the last known state
    def play(media_player:MediaPlayer) -> MediaPlayerState:
        client.info(name="Current Track", message=str(media_player.get_content_title()))
        ic(media_player.play())
        state = MediaPlayerState.PLAYING
        while (state != MediaPlayerState.STOPPED and
               state != MediaPlayerState.ROLL_BACK and 
               state != MediaPlayerState.SKIPPING): 
            state = ic(media_player.get_new_state())
        return state

    def is_mp4_corrupt(file_path):
        try:
            (
                ffmpeg
                .input(file_path)
                .output("null", f="null", loglevel="quiet")
                .run()
            )
        except ffmpeg._run.Error:
            return True
        else:
            return False
        

    def create_playback_from_video(video:pytube.YouTube, output_folder, file_type, retrys = 10) -> MediaPlayer | None:
        # output folder    
        if not os.path.exists(output_folder): os.makedirs(output_folder)
        ic(output_folder)

        # aquire data
        mp = None
        try:
            folder = os.path.join(output_folder, video.video_id) + "\\"
            ic(folder)
            if os.path.exists(folder):
                client.info(ic("Fetching from files..."))
                file_pat = os.path.join(folder, os.listdir(folder)[0])
                client.override(client.info, ic(f"Get '{video.title}' from file '{file_pat}'..."))
            else: 
                client.info(ic("Fetching from servers..."))
                file_ext = None if file_type == "any" else file_type
                stream = ic(video.streams.filter(only_audio=True, file_extension=file_ext).first())
                client.override(client.info, ic(f"Download '{video.title}'..."))
                file_pat = stream.download(folder)
                ic(f"File location: '{file_pat}'")
            ic("Done")

            if VideoPlaybackManager.is_mp4_corrupt(file_pat):
                # File is corrupted
                if retrys > 0:
                    # Delete and try to download again
                    client.warn(message=f"'{file_pat}' is corrupted. Weevil will try to delete and redownload the track. " + f"Retrys left: {str(retrys)}")
                    shutil.rmtree(file_pat)
                    mp = ic(VideoPlaybackManager.create_playback_from_video(video, output_folder, file_type, retrys-1))
                else:
                    # Unable to fetch file
                    client.fail(message=f"'{video.title}' cannot be safely downloaded. " + "No retrys left. " + f"'{video.title}' will be skipped.")
            else:
                ic(f"'{video.title}' aquired.") # Print nothing on success.
                mp = MediaPlayer()
                mp.load(file_pat, video.title, video.length)

        # Video is age restriced
        except AgeRestrictedError as e:
            client.warn(message=f"'{video.title}' is age restricted, and can't be accessed without logging in. " + f"<ID:{video.video_id}>")
        
        # Internal SSLError from pytube. Most at the time it's a network error
        except SSLError as e:
            if retrys > 0:
                client.fail(message=f"'{video.title}' could not be downloaded due to a network error. "+ f"Retrys left: {str(retrys)}")
                time.sleep(0.1)
                mp = ic(VideoPlaybackManager.create_playback_from_video(video, output_folder, file_type, retrys-1))
            else:
                client.fail(message=f"'{video.title}' could not be downloaded due to a network error. "+ "No retrys left. " + f"'{video.title}' will be skipped.")
            
        return mp
    

    def create_playback(url, output_folder, file_type) -> MediaPlayer | None:
        return ic(VideoPlaybackManager.create_playback_from_video( pytube.YouTube(url), output_folder, file_type))
    

class PlaybackManager:    
    
    def __init__(self):
        self.current = MediaPlayer()
        self.content_type = ContentType.NONE
        self._playlist = None
    

    def stop(self = None) -> bool:
        if (self is not None):
            if (self._playlist is not None):
                self._playlist.stop = True
            self.current.stop()
        return True


    def play(self, settings) -> bool:
        # get url
        if ("url" in settings):
            url = settings["url"]
        elif ("commons" in settings):
            import commons
            url =  commons.storage[settings["commons"]]

        # determine content type
        self.content_type = ContentType.NONE
        if re.search(r"(?:v=|\/)([0-9A-Za-z_-]{11}).*", url) is not None:
            self.content_type=ContentType.VIDEO
        if re.search(r"list=[0-9A-Za-z_-]+", url) is not None:
            self.content_type=ContentType.PLAYLIST
        ic (self.content_type)

        def callback(mp): 
            self.current = mp
            ic ("Update mp: ")
            ic (self.current)

        if self.content_type is ContentType.PLAYLIST:
            try:
                playback = PlaylistPlaybackManager( url, settings["output_folder"], settings["file_type"])
                self._playlist = playback;
                playback.play(callback)
            except: 
                return True

        if self.content_type is ContentType.VIDEO:
            try:                    
                ic("Create Playback")
                playback = VideoPlaybackManager.create_playback( url, settings["output_folder"], settings["file_type"])
                if playback is not None:
                    self.current = playback
                    ic("Play Playback")
                    VideoPlaybackManager.play(playback)
            except: 
                return True

        return True


class ContentType(enum.Enum):
    NONE = -1
    PLAYLIST = 0
    VIDEO = 1